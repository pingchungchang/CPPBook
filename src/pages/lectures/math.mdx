---
title: 'Math'
pubDate: 2024-10-16
description: 'Math'
author: 'PCC'
image:
    url: 'https://docs.astro.build/assets/rose.webp'
    alt: 'The Astro logo on a dark background with a pink glow.'
tags: ["Basic", "CPP"]
layout: '../../layouts/MyLayout.astro'
---
import { Image } from 'astro:assets';
import treeImage from '../../images/tree.png';

# Math (數學)
程式中用到的數學可能跟學校的有一些些不同

## 輾轉相除法
- 要怎麼求 gcd(a, b)?
- WLOG a < b ，定義 gcd(0, a) = a ，則會有 gcd(a, b) = gcd(a, b % a)
```cpp
int GCD(int a, int b) {
	if (a > b) swap(a, b);
	if (!a) return b;
	else return GCD(b, a % b);
}
```
- extend gcd：給 a, b, c, p, 求 $ax + by = c \ mod \ p$ 的 x, y

## Modulo

### 一些名詞們
- 通常會有一個模數 $p$
- Modulo: 取餘數 (a % p / a mod p)
- 同餘：$a \equiv b \text{ (mod p)}\  iff \ a \ mod\  p = b \ mod \ p$

### 加減乘法：
- 同餘下，正常運算的加減乘法都可以正常運作 (a + b) % p = (a % p + b % p) % p ，但是自己注意不要算一算爆出 int/long long 範圍

```cpp
const int mod = 1e9 + 7;
int mad(int a, int b) {
	a += b;
	if (a >= mod) a -= mod;
	return a;
}
int mub(int a, int b) {
	if (a >= b) return a - b;
	else return a + mod - b;
}
int mul(int a, int b) {
	return 1ll * a * b % mod;
}
```
- 通常同餘會出現在排列組合的題目中，因為答案可能會很大導致答案不能用一個 int/long long 表示，因而要求大家取餘數後輸出
- 注意到 "%" 跟加減法比起來很慢，所以不要太常使用不然有可能會被卡常數


### 除法
- 我們定義 $a^{-1} = b \ s.t. \ a \times b \ mod \ p = 1$
- 有時候 $a^{-1}$ 不一定存在，比如說 $p=4, a = 2$
- 但是，如果 $a \% p \ne 0$ 且 $p$ 是質數，那 $a^{-1}$ 就一定存在
	- 費馬小定理：$a^{p-1} \equiv 1 \ mod \ p \leftrightarrow a \times a ^ {p-2} \equiv 1 \ mod \ p$
- 可能會發現要很快的算 pow(a, p-2) -> 用倍增!
```cpp
int pw(int a, int b) {
	int re = 1;
	int dp = a;
	for (int i = 0; i < 30; i++) {
		if (b & (1<<i)) re = mul(re, dp);
		dp = mul(dp, dp);
	}
	return re;
}
```
可能要自己找到一個適合的寫法，像是我比較常用的寫法：
```cpp
int pw(int a, int b) {
	int re = 1;
	while(b) {
		if (b&1) re = mul(re, a);
		a = mul(a, a);
		b >>= 1;
	}
	return re;
}
```
- 總之，在 p 是質數的情況除了 0 以外都有乘法反元素


## 排列組合
### 階乘
```cpp
int fac[mxn], ifac[mxn];
fac[0] = 1;
for (int i = 1; i < mxn; i++) {
	fac[i] = mul(fac[i-1], i);
}
ifac[mxn-1] = inv(fac[mxn-1]);
for (int i = mxn-2; i >= 0; i--) {
	ifac[i] = mul(ifac[i+1], i+1);
}
```

### 排列組合
$(^n_k) = \frac{n!}{k!(n-k)!} = fac[n] \times ifac[k] \times ifac[n-k]$

有 $n$ 個球跟 $k$ 個箱子，有幾種放球跟箱子的相異放法
- 球跟箱子全部都不一樣: $k ^ n$
- 球跟箱子都相同：$H^n_k = (^{n+k-1}_n)$
### 數數例題
- [CF 1281 C](https://codeforces.com/contest/1281/problem/C)
- [CF 1279 D](https://codeforces.com/contest/1279/problem/D)
